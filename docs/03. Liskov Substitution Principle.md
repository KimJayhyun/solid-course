## 리스코프 치환 원칙 (Liskov Substitution Principle)

부모 클래스 객체를 자식 클래스 객체로 치환할 수 있어야 하며,

이것이 프로그램의 동작이나 특성에 영향을 주어서는 안 된다.

### 🎯 핵심 포인트

자식이 부모를 완전히 대체할 수 있으려면, 자식은 부모가 약속한 모든 것을 지킬 수 있어야 합니다. 만약 예외 사항이 있다면, 그것은 잘못된 상속 관계입니다.

## 예시

### ✅ 원칙을 지키는 경우: 새 (Bird) 계층

**상황:**

- 부모: "새" (일반적인 새)
- 자식들: "참새", "독수리", "까마귀"

모든 자식 새들은 부모 새가 할 수 있는 것(날기, 먹기, 둥지 만들기)을 똑같이 할 수 있습니다.

프로그램에서 "새"를 사용하는 곳에 "참새"나 "독수리"를 넣어도 아무 문제가 없습니다.

### ❌ 원칙을 위반하는 경우: 새와 펭귄

**상황:**

- 부모: "새" (날 수 있는 새)
- 자식: "펭귄"

문제가 발생합니다!

일반적인 새는 날 수 있지만, 펭귄은 새임에도 날 수 없습니다.

**실제 상황으로 비유하면:** 동물원 관리 시스템에서 "모든 새들을 새장에서 하늘로 날려보내라"는 명령을 내렸을 때:

- 참새, 독수리 → 문제없이 날아감
- 펭귄 → 땅에 떨어짐 (예상치 못한 동작!)

이는 "새" 자리에 "펭귄"을 넣었을 때 프로그램이 예상대로 작동하지 않는다는 뜻입니다.

## 리팩토링 이전

- [소스 코드](https://github.com/KimJayhyun/solid-course/tree/919cc6bd7af58e3aabb3f8c5a9f3fc300bfd6a72/src/main/java/com/company/liskov_1)

1.  **`Rectangle` (직사각형) 클래스:**

    - `width`와 `height`를 독립적으로 설정할 수 있습니다.
    - `setWidth()`는 `width` 값만 변경하고, `setHeight()`는 `height` 값만 변경합니다. 이것이 `Rectangle` 클래스의 암묵적인 동작 방식(규약)입니다.

2.  **`Square` (정사각형) 클래스:**
    - `Rectangle`을 상속받습니다. 정사각형은 직사각형의 한 종류라는 논리적 관계에 기반합니다.
    - 하지만 `Square`는 `setWidth()`나 `setHeight()`가 호출될 때, `width`와 `height`를 **항상 같은 값으로** 만듭니다. 예를 들어 `setWidth(30)`을 호출하면 `height`도 30으로 변경됩니다.
    - 이는 부모 클래스인 `Rectangle`의 동작 방식(규약)을 명백히 위반합니다.

### 위반이 드러나는 지점 (`Main.java`)

`Main.java`의 `useRectangle` 메소드는 이 문제를 명확하게 보여줍니다.

```java
private static void useRectangle(Rectangle rectangle) {
    rectangle.setHeight(20);
    rectangle.setWidth(30);
    assert rectangle.getHeight() == 20 : "Height Not equal to 20";
    assert rectangle.getWidth() == 30 : "Width Not equal to 30";
}
```

- **`useRectangle(rectangle)` 호출 시:**

  1.  `rectangle.setHeight(20)`: 높이가 20이 됩니다. (너비는 그대로)
  2.  `rectangle.setWidth(30)`: 너비가 30이 됩니다. (높이는 그대로 20)
  3.  `assert rectangle.getHeight() == 20` : **성공**
  4.  `assert rectangle.getWidth() == 30` : **성공**

- **`useRectangle(square)` 호출 시:**
  1.  `rectangle.setHeight(20)`: `Square`의 오버라이드된 메소드가 호출되어 너비와 높이가 모두 20이 됩니다.
  2.  `rectangle.setWidth(30)`: 너비와 높이가 모두 30으로 변경됩니다.
  3.  `assert rectangle.getHeight() == 20` : **실패!** `setWidth(30)`을 호출하면서 높이까지 30으로 변경되었기 때문에 `getHeight()`는 30을 반환합니다.
  4.  프로그램 실행 시 이 지점에서 `AssertionError`가 발생합니다.

### 결론

`Square` 객체를 `Rectangle` 타입으로 사용하는 `useRectangle` 메소드에서 예상치 못한 동작(Assertion 실패)이 발생했습니다. 이는 자식 클래스(`Square`)가 부모 클래스(`Rectangle`)의 동작 규약을 깨뜨려서, 부모 클래스가 사용되는 곳을 대체할 수 없게 되었기 때문입니다.

따라서 이 코드는 리스코프 치환 원칙을 위반합니다.

## 리팩토링 이후 (LSP 만족)

- [리팩토링](https://github.com/KimJayhyun/solid-course/tree/main/src/main/java/com/company/liskov_1)

1.  **`Shape` 인터페이스 도입**

    - `Rectangle`과 `Square`의 공통 기능(`computeArea()`)을 추출하여 `Shape`라는 새로운 인터페이스를 만들었습니다.

2.  **상속 관계 제거 (가장 중요한 변경점)**

    - `Square`가 `Rectangle`을 상속받던(`extends`) 관계를 끊었습니다.
    - 대신, `Rectangle`과 `Square`는 동등한 관계에서 `Shape` 인터페이스를 구현(`implements`)합니다. 이로써 둘은 부모-자식 관계가 아닌 '형제' 관계가 되었습니다.

3.  **`Square` 클래스의 독립**

    - `Square`는 이제 `Rectangle`의 `setWidth`, `setHeight` 메소드를 상속받지 않습니다.
    - 대신 `side`라는 자신만의 속성을 가지고, `computeArea()` 메소드를 직접 구현합니다. 이로써 부모의 동작(너비와 높이가 독립적으로 변하는)을 훼손할 여지가 완전히 사라졌습니다.

4.  **`Main` 클래스의 변경**
    - 기존에 문제를 일으켰던 `useRectangle(square);` 코드가 삭제되었습니다.
    - `Square`는 더 이상 `Rectangle` 타입이 아니므로, `useRectangle` 메소드에 전달할 수 없습니다. 이제는 코드를 컴파일하는 시점에서부터 잘못된 타입 전달을 막을 수 있게 되었습니다.

### 결론: 어떻게 LSP를 만족하게 되었는가?

핵심은 **잘못된 상속 관계를 바로잡은 것**입니다.

정사각형(Square)은 직사각형(Rectangle)과 동작 방식(규약)이 다르기 때문에, "Square is-a Rectangle" 관계는 성립하지 않았습니다. 수정된 코드는 이 관계를 끊고, `Shape`라는 공통 분모를 통해 둘을 묶어주었습니다.

이제 `Rectangle`이 필요한 곳에 `Square`를 전달하려는 시도 자체가 불가능해졌으므로, 런타임에 예상치 못한 오류가 발생할 가능성이 원천적으로 차단됩니다. 이것이 바로 리스코프 치환 원칙을 만족시키는 올바른 설계입니다.
