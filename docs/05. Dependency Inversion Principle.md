## 정의

1. **High level modules should not depend upon low level modules. Both should depend upon abstractions**

   - 상위 모듈은 하위 모듈에 의존해서는 안 된다. 둘 다 추상화에 의존해야 한다

2. **Abstractions should not depend upon details. Details should depend upon abstractions**

   - 추상화는 세부사항에 의존해서는 안 된다. 세부사항이 추상화에 의존해야 한다

### 기본 개념

일반적으로 프로그램을 만들 때 "구체적인 것"에 의존하지 말고, "추상적인 것"에 의존하라는 원칙입니다.

## 핵심 개념

### 상위 모듈 vs 하위 모듈

- **상위 모듈**: 비즈니스 로직, 정책, 도메인에 특화된 모듈 (재사용성 낮음)
  - 예: `OrderService`, `UserService`, `PaymentProcessor`
- **하위 모듈**: 기술적 구현, 어디서든 사용 가능한 범용 모듈 (재사용성 높음)
  - 예: `MySQLDatabase`, `EmailSender`, `Logger`, `HttpClient`

### "역전(Inversion)"의 의미

전통적 방식에서는 상위 모듈이 하위 모듈의 구체적인 구현에 직접 의존했지만,

DIP는 이 의존성의 방향을 역전시켜 **둘 다 추상화(인터페이스)에 의존**하도록 합니다.

## 코드 예시

### ❌ DIP 위반

```python
class MySQLDatabase:
    def save(self, data):
        print(f"MySQL에 저장: {data}")

class OrderService:  # 상위 모듈
    def __init__(self):
        self.db = MySQLDatabase()  # 하위 모듈에 직접 의존

    def save_order(self, order):
        self.db.save(order)
```

**문제점**: `OrderService`가 `MySQLDatabase`에 직접 의존하므로 데이터베이스를 변경하려면 상위 모듈을 수정해야 함

### ✅ DIP 준수

```python
from abc import ABC, abstractmethod

# 추상화
class Database(ABC):
    @abstractmethod
    def save(self, data):
        pass

# 하위 모듈 - 추상화에 의존
class MySQLDatabase(Database):
    def save(self, data):
        print(f"MySQL에 저장: {data}")

class PostgreSQLDatabase(Database):
    def save(self, data):
        print(f"PostgreSQL에 저장: {data}")

# 상위 모듈 - 추상화에 의존
class OrderService:
    def __init__(self, db: Database):
        self.db = db

    def save_order(self, order):
        self.db.save(order)
```

## 의존성 방향의 역전

```
전통적 방식:
[상위: OrderService]
        ↓ 의존
[하위: MySQLDatabase]

DIP 적용:
[상위: OrderService] → [추상화: Database] ← [하위: MySQLDatabase]
                의존                    의존
```

하위 모듈이 상위 모듈(또는 추상화)을 따라가게 되므로 **의존성이 역전**됩니다.

## 장점

- **유연성**: 구현체를 쉽게 교체 가능
- **테스트 용이성**: Mock 객체로 대체하여 테스트 가능
- **재사용성**: 상위 모듈을 다양한 하위 모듈과 조합 가능
- **결합도 감소**: 모듈 간 의존성이 약해짐
- **확장성**: 새로운 구현체 추가가 기존 코드 수정 없이 가능

## 리팩토링 전

- [소스 코드](https://github.com/KimJayhyun/solid-course/tree/ea497c98298a63bb5006bdbabd4e850683a19c10/src/main/java/com/company/depinv)

### 위반 코드: `MessagePrinter.java`

```java
public class MessagePrinter {

	//Writes message to a file
	public void writeMessage(Message msg, String fileName) throws IOException {

		Formatter formatter = new JSONFormatter(); // <-- DIP 위반 지점
		try(PrintWriter writer = new PrintWriter(new FileWriter(fileName))) {
			writer.println(formatter.format(msg)); // formating the message
			writer.flush();
		}
	}
}
```

### 위반 내용 설명

1.  **"상위 수준 모듈은 하위 수준 모듈에 의존해서는 안 된다. 둘 다 추상화에 의존해야 한다."**

    - `MessagePrinter` 클래스(메시지 출력을 담당하는 상위 모듈)는
      `JSONFormatter` 클래스(특정 포맷팅을 구현하는 하위 모듈)에 직접 의존하고 있습니다.
      `MessagePrinter`는 `JSONFormatter`의 구체적인 구현을 직접 생성하고 사용합니다.

1.  **"추상화는 세부 사항에 의존해서는 안 된다. 세부 사항이 추상화에 의존해야 한다."**
    - `MessagePrinter`는 `JSONFormatter`라는 구체적인 "세부 사항"과 강하게 결합(tightly coupled)되어 있습니다.
    - 만약 포맷팅 방식을 일반 텍스트(`TextFormatter`)로 변경하고 싶다면, `MessagePrinter` 클래스의 코드를 직접 수정해야만 합니다. 이는 변화에 유연하게 대처할 수 없는 구조입니다.

### 해결 방안: 의존성 주입 (Dependency Injection)

의존성 역전 원칙을 준수하기 위해 `MessagePrinter`는 구체적인 구현 클래스(`JSONFormatter`)가 아닌 `Formatter` 인터페이스(추상화)에 의존해야 합니다. 그리고 사용할 구체적인 포맷터 객체는 클래스 외부에서 생성하여 전달받아야 합니다. 이를 **의존성 주입(Dependency Injection)** 이라고 합니다.

## 리팩토링 후

- [소스 코드](https://github.com/KimJayhyun/solid-course/tree/main/src/main/java/com/company/depinv)

### 1. Formatter 추상화 (Interface)

다양한 포맷팅 방식을 아우를 수 있는 `Formatter` 인터페이스를 정의합니다. 이 인터페이스는 저수준 모듈(구체적인 포맷터)과 고수준 모듈(`MessagePrinter`)이 모두 의존해야 할 **추상화**입니다.

```java
// src/main/java/com/company/depinv/Formatter.java

package com.company.depinv;

// Common interface for classes formatting Message object
public interface Formatter {

	public String format(Message message) throws FormatException;

}
```

### 2. 추상화에 의존하는 구현체

기존의 구체적인 포맷팅 클래스들이 `Formatter` 인터페이스를 구현하도록 수정합니다.

**JSONFormatter.java**

```java
// src/main/java/com/company/depinv/JSONFormatter.java

package com.company.depinv;

// ... imports
public class JSONFormatter implements Formatter {

	public String format(Message message) throws FormatException {
		ObjectMapper mapper = new ObjectMapper();
		try {
			return mapper.writeValueAsString(message);
		} catch (JsonProcessingException e) {
			e.printStackTrace();
			throw new FormatException(e);
		}
	}
}
```

**TextFormatter.java**

```java
// src/main/java/com/company/depinv/TextFormatter.java

package com.company.depinv;

//Formats Message to plain text
public class TextFormatter implements Formatter{

	public String format(Message message){
		return message.getTimestamp()+":"+message.getMsg();
	}
}
```

### 3. 고수준 모듈 수정

고수준 모듈인 `MessagePrinter`가 구체적인 클래스가 아닌 `Formatter` 인터페이스에 의존하도록 수정합니다. 이제 `MessagePrinter`는 어떤 포맷터가 사용되는지 알 필요가 없으며, 단지 `Formatter`의 `format` 메서드를 호출할 뿐입니다.

필요한 의존성(구체적인 Formatter 객체)은 외부에서 주입받습니다.

```java
// src/main/java/com/company/depinv/MessagePrinter.java

package com.company.depinv;

import java.io.IOException;
import java.io.PrintWriter;

public class MessagePrinter {

	// Writes message to a file
	public void writeMessage(Message msg, Formatter formatter, PrintWriter writer) throws IOException {
		// 구체적인 Formatter가 아닌 Formatter 인터페이스에 의존
		writer.println(formatter.format(msg));
		writer.flush();
	}
}
```

### 4. 의존성 주입 (Dependency Injection)

제 3자(여기서는 `Main` 클래스)가 실제 사용할 구체적인 `Formatter` 객체를 생성하고, 이를 `MessagePrinter`에 주입(전달)합니다. 이로써 **제어의 흐름이 역전**됩니다. `MessagePrinter`가 스스로 의존성을 생성하는 것이 아니라, 외부에서 제어권을 가지고 의존성을 넣어주는 구조입니다.

```java
// src/main/java/com/company/depinv/Main.java

package com.company.depinv;

import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;

public class Main {

	public static void main(String[] args) throws IOException {

		Message msg = new Message("This is a message again");
		MessagePrinter printer = new MessagePrinter();

		// 1. JSONFormatter를 생성하여 주입
		try(PrintWriter writer = new PrintWriter(new FileWriter("test_msg.txt"))){
			printer.writeMessage(msg, new JSONFormatter(), writer);
		}

		// 2. PrintWriter와 함께 다른 Formatter(여기서는 JSONFormatter)를 주입
		try(PrintWriter writer = new PrintWriter(System.out)){
			printer.writeMessage(msg, new JSONFormatter(), writer);
		}

		// 만약 TextFormatter를 사용하고 싶다면?
		// printer.writeMessage(msg, new TextFormatter(), writer);
		// 와 같이 간단하게 교체할 수 있다.
	}
}
```

### 결론

- **고수준 모듈(`MessagePrinter`)은 저수준 모듈(`JSONFormatter`)에 의존하지 않고, 추상화(`Formatter`)에 의존합니다.**
- **추상화(`Formatter`)는 세부 사항(`JSONFormatter`)에 의존하지 않으며, 오히려 세부사항이 추상화에 의존합니다.**

이 리팩토링을 통해 `MessagePrinter` 코드를 전혀 수정하지 않고도 `XMLFormatter`, `CSVFormatter` 등 새로운 포맷 방식을 얼마든지 추가할 수 있는 유연하고 확장 가능한 구조가 되었습니다.
