## 정의

Open-Closed Principle (OCP, 개방-폐쇄 원칙)은 SOLID 원칙 중 하나로, "소프트웨어 엔티티(클래스, 모듈, 함수 등)는 확장에는 열려 있어야 하고, 수정에는 닫혀 있어야 한다"는 원칙입니다.

**핵심 개념:**

- **확장에 열려있다**: 새로운 기능을 추가할 수 있어야 함
- **수정에 닫혀있다**: 기존 코드를 변경하지 않아야 함

**왜 중요한가?**
기존 코드를 수정하면 버그가 발생할 위험이 있고, 테스트를 다시 해야 합니다. OCP를 따르면 새 기능을 추가할 때 기존 코드의 안정성을 유지할 수 있습니다.

**잘못된 예시 (OCP 위반):**

```python
class PaymentProcessor:
    def process_payment(self, payment_type, amount):
        if payment_type == "credit_card":
            # 신용카드 처리
            print(f"Processing credit card payment: {amount}")
        elif payment_type == "paypal":
            # PayPal 처리
            print(f"Processing PayPal payment: {amount}")
        # 새로운 결제 수단을 추가하려면 이 클래스를 수정해야 함
```

**올바른 예시 (OCP 준수):**

```python
from abc import ABC, abstractmethod

class PaymentMethod(ABC):
    @abstractmethod
    def process(self, amount):
        pass

class CreditCardPayment(PaymentMethod):
    def process(self, amount):
        print(f"Processing credit card payment: {amount}")

class PayPalPayment(PaymentMethod):
    def process(self, amount):
        print(f"Processing PayPal payment: {amount}")

class PaymentProcessor:
    def process_payment(self, payment_method: PaymentMethod, amount):
        payment_method.process(amount)

# 새로운 결제 수단 추가 시 기존 코드 수정 없이 확장 가능
class BitcoinPayment(PaymentMethod):
    def process(self, amount):
        print(f"Processing Bitcoin payment: {amount}")
```

**구현 방법:**

- 추상화(인터페이스, 추상 클래스) 활용
- 상속이나 구성(composition)을 통한 확장
- 전략 패턴, 템플릿 메서드 패턴 등의 디자인 패턴 활용

## 리팩토링 이전

- [ISPSubscriber.java](https://github.com/KimJayhyun/solid-course/blob/658f848363129cf9f3789fa7431c6731c9c28aff/src/main/java/com/company/openclose/ISPSubscriber.java)
- [PhoneSubscriber.java](https://github.com/KimJayhyun/solid-course/blob/658f848363129cf9f3789fa7431c6731c9c28aff/src/main/java/com/company/openclose/PhoneSubscriber.java)

### 현재 구조의 문제점

이 구조에서 요금을 계산하는 `Billing`이라는 클래스가 있다고 가정해 보겠습니다.

이 `Billing` 클래스는 아마 아래와 같이 각 가입자 유형(`instanceof`)을 확인하여 요금을 계산하는 코드를 포함하고 있을 것입니다.

```java
// OCP를 위반하는 방식의 코드 예시
public class Billing {

    public double calculateBill(Subscriber subscriber) {
        double bill = 0;

        if (subscriber instanceof PhoneSubscriber) {
            // PhoneSubscriber의 요금 계산 로직
            PhoneSubscriber phoneSubscriber = (PhoneSubscriber) subscriber;
            bill = phoneSubscriber.getBaseRate() + (phoneSubscriber.getSeconds() * 0.05);

        } else if (subscriber instanceof ISPSubscriber) {
            // ISPSubscriber의 요금 계산 로직
            ISPSubscriber ispSubscriber = (ISPSubscriber) subscriber;
            bill = ispSubscriber.getBaseRate() + (ispSubscriber.getDataUsed() * 0.1);
        }
        // ... 다른 유형의 가입자가 추가될 때마다 else if가 계속 추가되어야 함

        return bill;
    }
}
```

**이것이 바로 OCP를 위반하는 지점입니다.**

만약 `TVSubscriber`라는 새로운 유형의 가입자가 추가된다면,

`Billing` 클래스의 `calculateBill` 메서드 안에 `else if (subscriber instanceof TVSubscriber)` 구문을 **추가로 수정해야만 합니다.**

- **수정에 닫혀 있어야 한다 (Closed for Modification)**: 새로운 기능(TV 가입자)이 추가될 때마다 기존의 `Billing` 클래스 코드가 계속 변경되고 있으므로, 이 원칙을 위반합니다.
- **확장에 열려 있어야 한다 (Open for Extension)**: 새로운 클래스를 추가하는 것만으로 기능이 확장되지 않고, 기존 코드의 변경이 필요합니다.

## 리팩토링 이후

- [리팩토링](https://github.com/KimJayhyun/solid-course/tree/9a97a8b9f00bc7d91e61436a68566a94c0f2c6fa/src/main/java/com/company/openclose)

1.  **추상 메서드 정의**: 부모 클래스인 `Subscriber`에 `calculateBill()`이라는 추상 메서드를 만듭니다.

```java
// Subscriber.java
public abstract class Subscriber {
    // ... 기존 코드
    public abstract double calculateBill();
}
```

2.  **메서드 구현**: 각 하위 클래스(`PhoneSubscriber`, `ISPSubscriber`)에서 `calculateBill()` 메서드를 자신에게 맞게 구현(Override)합니다.

```java
// PhoneSubscriber.java
@Override
public double calculateBill() {
    return getBaseRate() + (getSeconds() * 0.05);
}
```

```java
// ISPSubscriber.java
@Override
public double calculateBill() {
    return getBaseRate() + (getDataUsed() * 0.1);
}
```

3.  **사용하는 클래스 수정**: 이제 `Billing` 클래스는 더 이상 가입자의 유형을 알 필요가 없어집니다.

```java
// OCP를 준수하는 방식의 코드
public class Billing {
    public double calculateBill(Subscriber subscriber) {
        // 어떤 유형의 Subscriber 인지 신경쓰지 않고, 그냥 calculateBill() 메서드만 호출
        return subscriber.calculateBill();
    }
}
```
