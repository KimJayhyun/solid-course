## 정의

**클라이언트는 자신이 사용하지 않는 메서드에 의존하도록 강요받아서는 안 된다.**

하나의 거대한 인터페이스보다 여러 개의 작고 구체적인 인터페이스로 분리하라.

### Interface Pollution: 피해야 할 3가지 징후

코드에서 다음 현상이 보인다면 ISP를 위반하고 있다는 신호:

#### 1. 빈 메서드 구현

```java
class Sparrow implements Bird {
    public void fly() { /* 구현됨 */ }
    public void swim() { } // 빈 구현!
}
```

#### 2. UnsupportedOperationException 던지기

```java
class Penguin implements Bird {
    public void fly() {
        throw new UnsupportedOperationException();
    }
}
```

#### 3. null 또는 더미 값 반환

```java
class TextDocument implements Document {
    public Image getThumbnail() {
        return null; // 의미 없는 null
    }
}
```

→ **이 징후들은 "필요 없는 메서드를 억지로 구현하고 있다"는 증거**

---

### 해결책: Mixin 패턴

ISP를 실천하는 방법 - 작은 기능 단위를 필요한 만큼만 조합

#### Python 예시

```python
class FlyableMixin:
    def fly(self): pass

class SwimmableMixin:
    def swim(self): pass

class Duck(FlyableMixin, SwimmableMixin): pass
class Penguin(SwimmableMixin): pass
```

## 리팩토링 이전

- [소스 코드](https://github.com/KimJayhyun/solid-course/tree/68e715c46e7d0cd5242adae4232f2b3ce66441ac/src/main/java/com/company/intersegrega/service)

### 1. "비대한(Fat)" 인터페이스: `PersistenceService.java`

`PersistenceService` 인터페이스는 모든 영속성 관련 서비스가 구현해야 할 공통 계약을 정의하고 있습니다.

```java
// src/main/java/com/company/intersegrega/service/PersistenceService.java
public interface PersistenceService<T extends Entity> {
    public void save(T entity);
    public void delete(T entity);
    public T findById(Long id);
    public List<T> findByName(String name); // ISP 위반의 핵심 원인
}
```

여기서 문제는 `findByName(String name)` 메서드입니다.

이 메서드는 인터페이스를 구현하는 모든 `T` 타입의 엔티티가 `name`이라는 속성을 가지고 이름으로 검색이 가능하다고 가정합니다.

### 2. 엔티티 클래스들의 속성 차이

- `User.java`: `name` 속성을 가지고 있습니다. 따라서 `UserPersistenceService`는 `findByName` 메서드를 자연스럽게 구현할 수 있습니다.
- `Order.java`: `orderPlacedOn`과 `totalValue` 속성은 있지만, `name` 속성은 가지고 있지 않습니다.

### 3. ISP 위반 발생 지점

`PersistenceService` 인터페이스를 구현하는 `UserPersistenceService`의 경우, `User` 엔티티가 `name` 속성을 가지므로 `findByName`을 구현하는 데 문제가 없습니다.

```java
// src/main/java/com/company/intersegrega/service/UserPersistenceService.java
// ...
public class UserPersistenceService implements PersistenceService<User> {
    // ...
    @Override
    public List<User> findByName(String name) {
        // User 엔티티에는 name 속성이 있어 구현 가능
        return USERS.values().stream().filter(u->u.getName().equalsIgnoreCase(name)).collect(Collectors.toList());
    }
}
```

하지만, `Order` 엔티티를 위한 `OrderPersistenceService`가 이 `PersistenceService` 인터페이스를 구현한다고 가정해 봅시다.

```java
// (가상의 코드) src/main/java/com/company/intersegrega/service/OrderPersistenceService.java
import com.company.intersegrega.entity.Order;
import java.util.List;
import java.util.Collections; // 예시를 위해 추가

public class OrderPersistenceService implements PersistenceService<Order> {

    @Override
    public void save(Order entity) { /* 구현 */ }

    @Override
    public void delete(Order entity) { /* 구현 */ }

    @Override
    public Order findById(Long id) { /* 구현 */ return null; }

    @Override
    public List<Order> findByName(String name) {
        // Order 엔티티에는 'name' 속성이 없습니다.
        // 이 메서드는 OrderPersistenceService에게 불필요하고 무의미합니다.
        // 구현을 강제당하므로 UnsupportedOperationException을 던지거나
        // 빈 리스트를 반환하는 방식으로 "억지로" 구현해야 합니다.
        throw new UnsupportedOperationException("Order 엔티티는 이름으로 검색할 수 없습니다.");
        // 또는 return Collections.emptyList();
    }
}
```

`OrderPersistenceService`는 `Order` 엔티티에 `name` 속성이 없음에도 불구하고 `PersistenceService` 인터페이스 때문에 `findByName` 메서드를 **강제로 구현**해야 합니다. 이는 클라이언트(`OrderPersistenceService`)가 자신이 사용하지도 않고 필요하지도 않은 메서드에 의존하도록 강요받는 상황이며, ISP를 명백히 위반하는 것입니다.

## ISP 위반이 초래하는 문제점

1.  **불필요한 종속성**: 클라이언트가 사용하지 않는 메서드에 종속되어 코드의 응집도를 떨어뜨립니다.
2.  **구현의 어려움**: 필요 없는 메서드를 억지로 구현해야 하므로 `UnsupportedOperationException`을 던지거나 빈 구현을 하게 되어 코드의 가독성과 유지보수성을 저해합니다.
3.  **유연성 저하**: 새로운 엔티티 타입이 추가될 때마다, 그 엔티티가 `name` 속성이 없더라도 `findByName`을 구현해야 하는 제약이 발생합니다.

## 리팩토링 이후

- [소스 코드](https://github.com/KimJayhyun/solid-course/tree/main/src/main/java/com/company/intersegrega/service)

`PersistenceService` 인터페이스에서 `findByName` 메서드를 제거하고,

해당 기능을 필요한 구체 클래스(예: `UserPersistenceService`) 내부에서만 유지함으로써 해결되었습니다.

### 1. `PersistenceService.java` 변경 사항

`src/main/java/com/company/intersegrega/service/PersistenceService.java` 파일에서 `findByName` 메서드가 주석 처리되었습니다.

```java
// src/main/java/com/company/intersegrega/service/PersistenceService.java
public interface PersistenceService<T extends Entity> {
    public void save(T entity);
    public void delete(T entity);
    public T findById(Long id);

    // 한 Class에서만 사용하는 Method를 제거하여
    // Interface Segregation Principle를 충족
    // public List<T> findByName(String name); // 주석 처리됨
}
```

### 2. `UserPersistenceService.java` 변경 사항

`src/main/java/com/company/intersegrega/service/UserPersistenceService.java` 파일에서 `findByName` 메서드의 `@Override` 어노테이션이 주석 처리되었습니다.

```java
// src/main/java/com/company/intersegrega/service/UserPersistenceService.java
public class UserPersistenceService implements PersistenceService<User>{
    // ...
    // @Override // PersistenceService에서 제거되었으므로 더 이상 오버라이드 아님
    public List<User> findByName(String name) {
        // ... 구현은 그대로 유지 ...
    }
}
```

## 해결 결과

- `PersistenceService`는 더 이상 "비대한" 인터페이스가 아닙니다.
- `OrderPersistenceService`와 같은 클래스는 이제 `findByName`을 구현할 필요가 없어졌으므로, 자신이 사용하지 않는 메서드에 의존하지 않게 되었습니다.
- 각 클라이언트(예: `UserPersistenceService`)는 자신이 필요한 기능만 구현하고 노출하게 되어 ISP를 준수하게 되었습니다.

이러한 변경을 통해 코드의 유연성이 향상되고, 불필요한 종속성이 제거되어 유지보수성이 개선되었습니다.
